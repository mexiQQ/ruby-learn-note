1> 对象方法消息机制，和 objective-C 类似
2> 
求一个值的绝对值

  //java
  number = Math.abs(number);

  //ruby
  number = number.abs

从上述例子可以看出，对于基本数据类型的操作（如求绝对值）内建在该数据类型中，而不是其他的类中，更能体现面向对象的理念。

3> 全局变量 $ 
   类变量 @@
   实例变量 @

4> 一些基本知识

  //ruby
  #!/usr/bin/ruby
  puts "hello world"

  $school = "SDU"
  @name = "SCU"
  def say_goodnight name
    #"good night, \n" + name
    #'good night, \n#{name}'
    "good night, \n#{name}"
  end

  puts say_goodnight("lijianwei")
  puts "#$school,#$name"  

>5 nil 是一个对象,不包含任何内容的空对象

>6 Array & Dictionary

  //ruby
  # Array
  a = [1,'cat','dog','lijianwei','ball']
  puts "#{a[0]}"
  puts "#{a[1]}"
  puts "#{a[2]}"
  puts "#{a[3]}"
  puts "#{a[4]}"
  puts "#{a[5]}"

  a[2] = nil
  puts "#{a[2]}"

  b = %w{hello lijianwei ni hao}
  puts b[2]

  # Dictionary
  dic1 = {
          'tom'   => 'lijianwei',
          'jerry' => 'lijianweini'
        }
  dic2 = {
          tom: 'lijianwei',
          jerry: 'lijianweini'
        }
  dic3 = {
          :tom   => 'lijianwei',
          :jerry => 'lijianweini'
        }
  puts dic1
  puts dic2
  puts dic3

7>  
  //ruby
  # Dictionary 语法糖

  dic4 = Hash.new(0)
  puts dic4['hello']
  dic4['hello'] = dic4['hello'] + 1
  puts dic4['hello']

8>
控制结构，不使用花括号，使用 end 标识符

9> if while 语句可以用作表达式 
  //ruby
  puts 'lijaiwnei' if 1000>999

  irb(main):011:0> a=2
  => 2
  irb(main):012:0> puts a=a*a while a<1000
  4
  16
  256
  65536
  => nil

10> 小括号在大多数控制结构中不需要写
 
11> 正则表达式  内建了正则表达式类 不需要通过接口的形势

12> Block  闭包
?? 为什么 Block  调用要使用 yield 呢？？

  def call_block 
    yield
    yield
  end

  call_block {puts 'hello world'}

  //和迭代器配合
  animals = %w{my name is lijianwei}
  animals.each {|animal| puts "#{animal}#{animal}"}

13> 尝试使用 ruby 的数组事先 stack  set queue dequeue 等数据结构

14> hash 在 OC 和 ruby 中都是最常用的对象 而数组是实现其他数据结构的基础 

15> ruby 中的Array 和 Hash 都是可变的

16> Array add a element
  Items can be added to the end of an array by u
  sing either #push or #<<

    arr = [1, 2, 3, 4]
    arr.push(5) #=> [1, 2, 3, 4, 5]
    arr << 6    #=> [1, 2, 3, 4, 5, 6]

  #unshift will add a new item to the beginning
  of an array.

    arr.unshift(0) #=> [0, 1, 2, 3, 4, 5, 6]

  With #insert you can add a new element to an array at any position.

    arr.insert(3, 'apple')  #=> [0, 1, 2, 'apple', 3, 4, 5, 6]

  Using the #insert method, you can also insert multiple values at once:

    arr.insert(3, 'orange', 'pear', 'grapefruit')
    #=> [0, 1, 2, "orange", "pear", "grapefruit", "apple", 3, 4, 5, 6]

17> Array delete a element

......

18> 迭代器 

内部迭代器 和 外部迭代器

ruby  的迭代器是内建于集合类的，不存在于类似java 中基于 Iterator 接口的对象

迭代器值得深入研究

19> 关于 block 使用的一个有趣的地方
文件类自己关闭文件（是否传递block参数 ）

  //ruby
  class File
    def File.open_and_process(*args)
        f = File.open(*args)
            yield f
                f.close
                  end
                  end

                  File.open_and_process("/Users/liwenqian/Desktop/tmp.txt","r") do |file|
                    while line = file.gets
                        puts line
                          end
                          end
    # 其实不需要自己写这个 open_and_process 的类方法 ，open 方法本身就支持 block 处理完成后自动关闭文件，但是前提是传入了 block 参数，有种 Kenel.block.given? 的味道

20> Block 作为闭包的用处

如下两个例子：

  //ruby
  songlist = SongList.new
  class BoxButton < Button
    def initialize(label,&action)
      super(label)
      @action = action
    end
    
    def button_process
      @action.call(self)
    end
  end

  start_button = BoxButton.new('start') {songlist.start}
  stop_buttopn = BoxButton.new('stop') {songlist.stop}

  //ruby
  def n_times(thing)
    return lambda {|n| thing*n}
  end

  proc = n_times(23)
  proc.call(3) => 69
  proc.call(4) => 92

如上所示：
  n_times 函数返回一个基于 thing 局部变量的Proc 对象

  然后之后调用这个 proc (block) 时，尽管thing已经出了其作用域，但是在block 中仍然有效访问

  这就是ruby里block起到的闭包作用

21> 














